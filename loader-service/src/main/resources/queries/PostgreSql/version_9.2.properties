metadata.query.server=SELECT\
   (substring(version(), '[0-9.]+')) AS version, \
   pg_postmaster_start_time()::VARCHAR AS uuid;
metadata.query.database=SELECT d.datname as name, d.datcollate as collation, \
  COALESCE(current_schema(), 'public') as default_schema \
  FROM pg_database d \
  WHERE d.datistemplate = false and d.datname = current_database(); 
metadata.query.schema=select current_database() AS parent_object_id, n.nspname as current_object_id, n.nspname as name, \
  CASE WHEN n.nspname like 'pg\_%' or n.nspname = 'information_schema' THEN 1 ELSE 0 END AS is_system \
  from pg_namespace n \
  where current_database() = ?
metadata.query.extension=select current_database() as parent_object_id, pn.nspname AS schema_name, pe.extname as current_object_id,\
  \ pe.extname as name, pe.extowner, pe.extnamespace, pe.extrelocatable, pe.extversion \
  from pg_extension pe, pg_namespace pn \
  where pe.extnamespace=pn.oid and current_database() = ?
metadata.query.table=select nc.nspname AS parent_object_id, c.relname AS name, \
  concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN t.typname IS NOT NULL THEN  1 ELSE 0 END AS is_typed_table \
  from ((pg_namespace nc JOIN pg_class c ON ((nc.oid = c.relnamespace))) \
  LEFT JOIN (pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid))) \
  where (NOT pg_is_other_temp_schema(nc.oid)) AND (c.relkind = 'r'::"char") AND current_database() = ? AND nc.nspname = ?
metadata.query.view=select c.relname AS name, concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 1 ELSE 0 END as is_updatable, \
  pg_get_viewdef(c.oid) AS text \
  from pg_namespace nc, pg_class c \
  where (c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
  AND current_database() = ? AND nc.nspname = ?
metadata.query.materialized-view=select schemaname as parent_object_id,matviewname as name, \
  schemaname || '.' || matviewname AS current_object_id, ispopulated as is_updatable, hasindexes as has_indexes, \
  definition as text \
  from pg_matviews where current_database() = ? and schemaname = ?
metadata.query.procedure=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.aggregate-function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and prc.proisagg = true \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.sequence=select \
        c.relname AS current_object_id, \
        false as is_udt, \
        c.relname AS name, \
        'bigint'::character varying AS type_name,  \
        p.start_value AS start_value, \
        p.minimum_value AS minimum_value, \
        p.maximum_value AS character_maximum_length, \
        p.increment AS increment, \
        64::information_schema.cardinal_number AS numeric_precision, \
        0::information_schema.cardinal_number AS numeric_scale, \
        CASE WHEN (CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) = 'YES' THEN true ELSE false END as cycle_option \
        ,false as cache_flag \
        ,null as cache_size \
        ,null as last_value  \
    from    pg_namespace nc, \
        pg_class c, \
        LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
    where \
    (c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
        and current_database() = ? \
        and nc.nspname = ?
metadata.query.udt=SELECT \
        m.parent_object_id, \
        m.current_object_id, \
        m.name, \
        m.type_name, \
        m.udt_name, \
        m.udt_schema, \
        coalesce(m.character_maximum_length, m.character_maximum_length_calc) as character_maximum_length, \
        case when trim(m.parent_object_id) is null then false else true end as is_udt, \
        m.domain_schema, \
        m.database, \
        m.numeric_precision, \
        m.numeric_scale, \
        m.allow_nulls, \
        m.is_domain, \
        m.is_type_enum \
    FROM ( \
            SELECT \
                ns.nspname as parent_object_id, \
                current_database() as database, \
                concat_ws('.', ns.nspname, t.typname ) as current_object_id, \
                t.typname as name, \
                CASE \
                WHEN c.data_type = 'USER-DEFINED' \
                THEN replace(replace(format_Type(t.typbasetype,null),c.udt_schema||'.',''),'[]','') \
                ELSE c.data_type \
                END  as type_name, \
                c.udt_name, \
                c.udt_schema, \
                COALESCE(c.domain_schema, '') as domain_schema, \
                c.character_maximum_length, \
                coalesce(c.numeric_precision, c.datetime_precision) as numeric_precision, \
                c.numeric_scale, \
                case when t.typnotnull = 't' then false else true end as allow_nulls, \
                CASE WHEN c.udt_name in ('_char', '_varchar', '_bpchar') THEN \
                CASE WHEN t.typtypmod < 0 THEN null \
                ELSE (t.typtypmod - 4) & 65535 \
                END \
                ELSE null \
                END AS character_maximum_length_calc, \
                CASE WHEN (UPPER(t.typinput::varchar) = 'DOMAIN_IN') THEN true ELSE false END as is_domain, \
                CASE WHEN (upper(t.typinput::varchar) = 'ENUM_IN') THEN true ELSE false END as is_type_enum \
            FROM pg_catalog.pg_type t \
                LEFT JOIN pg_catalog.pg_namespace ns ON t.typnamespace = ns.oid \
                LEFT JOIN information_schema.domains c ON c.domain_name = t.typname and c.domain_schema = ns.nspname \
            WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) \
            AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid) \
            and current_database() = ? \
            AND ns.nspname = ? \
    ) m
metadata.query.column=select \
m.parent_object_id, \
m.table_name, \
m.name, \
m.current_object_id, \
m.database, \
case when coalesce(m.domain_schema, m.udt_schema) is not null \
then m.typname \
when strpos(m.displaytypname_full, '(')>0 and strpos(m.displaytypname_full, ')')>0 then \
CONCAT(left(m.displaytypname_full, strpos(m.displaytypname_full, '(')-1), right(m.displaytypname_full, length(m.displaytypname_full) - strpos(m.displaytypname_full, ')'))) \
else m.displaytypname_full \
end type_name, \
m.typname as type_name_alias, \
m.character_maximum_length, \
coalesce(m.numeric_precision) as numeric_precision, \
m.numeric_scale, m.is_identity, \
case when m.table_type = 'BASE TABLE' then m.is_nullable else null end as is_nullable, \
case when coalesce(m.domain_schema, m.udt_schema) is null then false else true end as is_udt, \
m.domain_schema, m.udt_schema, \
m.is_generated, m.column_default, m.ordinal_position, m.collation_name, m.minimum_value, m.increment  \
from \
( select \
c.table_name, \
c.domain_schema, \
CASE WHEN c.udt_schema NOT IN ('pg_catalog') THEN  c.udt_schema ELSE NULL END AS udt_schema, \
c.column_name as name, \
CONCAT_WS('.', c.table_schema, c.table_name) as parent_object_id, \
CONCAT_WS('.', c.table_schema, c.table_name, c.column_name) as current_object_id, \
current_database() as database, \
replace(format_type(pg.oid,pg.atttypmod), coalesce(coalesce(c.domain_schema, c.udt_schema), '')||'.','') AS displaytypname_full, \
pg.typname, \
coalesce(c.character_maximum_length, pg.character_maximum_length) as character_maximum_length, \
coalesce(c.numeric_precision, pg.numeric_precision, c.datetime_precision) as numeric_precision, \
coalesce(c.numeric_scale, pg.numeric_scale) as numeric_scale, \
case when c.is_identity= 'NO' then false \
else true \
end as is_identity, \
case when c.is_nullable= 'NO' then false \
else true \
end as is_nullable, \
is_generated, \
c.column_default, \
c.ordinal_position, \
collation_name, \
seq.minimum_value::Decimal, \
seq.increment::Decimal, \
c.table_catalog, \
c.table_schema, \
(SELECT CASE \
WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text \
WHEN (cc.relkind = 'r'::"char") THEN 'BASE TABLE'::text \
WHEN(cc.relkind = 'v'::"char") THEN 'VIEW'::text \
WHEN(cc.relkind = 'f'::"char") THEN 'FOREIGN TABLE'::text \
ELSE NULL::text \
END AS table_type \
FROM pg_namespace nc \
JOIN pg_class cc ON nc.oid = cc.relnamespace \
WHERE cc.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char"]) \
AND NOT pg_is_other_temp_schema(nc.oid) \
AND current_database()= c.table_catalog \
AND nc.nspname= c.table_schema \
AND cc.relname= c.table_name) table_type \
from \
( \
SELECT current_database() AS table_catalog, \
nc.nspname AS table_schema, \
c.relname AS table_name, \
a.attname AS column_name, \
a.attnum AS ordinal_position, \
pg_get_expr(ad.adbin, ad.adrelid) AS column_default, \
CASE WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text \
ELSE 'YES'::text END AS is_nullable, \
information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS character_maximum_length, \
information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS numeric_precision, \
information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS numeric_scale, \
information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS datetime_precision, \
nco.nspname AS collation_schema, \
co.collname AS collation_name, \
CASE \
WHEN(t.typtype = 'd'::"char") THEN nt.nspname \
ELSE NULL::name \
END AS domain_schema, \
COALESCE(nbt.nspname, nt.nspname) AS udt_schema, \
'NO'::character varying AS is_identity, \
'NEVER'::character varying AS is_generated \
FROM(((((pg_attribute a \
LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND(a.attnum = ad.adnum)))) \
JOIN(pg_class c \
JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON((a.attrelid = c.oid))) \
JOIN(pg_type t \
JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON((a.atttypid = t.oid))) \
LEFT JOIN(pg_type bt \
JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON(((t.typtype = 'd'::"char") AND(t.typbasetype = bt.oid)))) \
LEFT JOIN(pg_collation co \
JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON(((a.attcollation = co.oid) AND((nco.nspname<> 'pg_catalog'::name) OR(co.collname<> 'default'::name))))) \
WHERE(NOT pg_is_other_temp_schema(nc.oid)) AND(a.attnum > 0) AND(NOT a.attisdropped) AND(c.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char", 'm'::"char"])) \
) c \
left outer join \
(select substring(tmp_seq.tmp_name_seq, tmp_seq.pos_from, tmp_seq.pos_end-tmp_seq.pos_from+1) seq_name, tmp_seq.column_default \
,tmp_seq.table_catalog, tmp_seq.table_schema, tmp_seq.table_name, tmp_seq.column_name, tmp_sequences_schema, i_seq.* \
from \
(SELECT replace(pg_get_expr(ad.adbin, ad.adrelid), '"', '') tmp_name_seq, \
case when strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')>0 \
Then strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')+1 \
else strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), 'nextval(')+9 end as pos_from, \
strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '::')-2 as pos_end, \
pg_get_expr(ad.adbin, ad.adrelid) column_default, \
current_database() table_catalog, \
nc.nspname table_schema, \
c.relname table_name, \
a.attname column_name, \
case when strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')>0 \
Then substring(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), 10,strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')-10) \
else nc.nspname end as tmp_sequences_schema \
FROM(pg_attribute a LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum) \
JOIN \
(pg_class c JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid \
WHERE (NOT pg_is_other_temp_schema(nc.oid)) AND(a.attnum > 0) AND(NOT a.attisdropped) AND(c.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char"])) \
AND strpos((pg_get_expr(ad.adbin, ad.adrelid)), 'nextval(') > 0 \
) tmp_seq, \
(SELECT current_database() AS sequence_catalog, \
nc.nspname AS sequence_schema, \
c.relname AS sequence_name, \
'bigint'::character varying AS data_type, \
64::information_schema.cardinal_number AS numeric_precision, \
2::information_schema.cardinal_number AS numeric_precision_radix, \
0::information_schema.cardinal_number AS numeric_scale, \
p.start_value AS start_value, \
p.minimum_value AS minimum_value, \
p.maximum_value AS maximum_value, \
p.increment AS increment, \
(CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) AS cycle_option \
FROM pg_namespace nc, pg_class c, \
LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
WHERE(c.relnamespace = nc.oid) AND(c.relkind = 'S'::"char") AND(NOT pg_is_other_temp_schema(nc.oid)) \
) i_seq \
where substring(tmp_seq.tmp_name_seq, tmp_seq.pos_from, tmp_seq.pos_end-tmp_seq.pos_from+1)=i_seq.sequence_name \
and i_seq.sequence_catalog = tmp_seq.table_catalog \
and i_seq.sequence_schema = tmp_seq.tmp_sequences_schema \
) seq on  c.table_catalog = seq.table_catalog \
and c.table_schema = seq.table_schema \
and c.table_name = seq.table_name \
and c.column_name = seq.column_name \
left outer join \
(SELECT ty.oid, att.atttypmod, \
ty.typname, \
nc.nspname , pg_cl.relname, att.attname, \
CASE WHEN ty.typname in ('int2', '_int2') THEN 16 \
WHEN ty.typname in ('int4', '_int4') THEN 32 \
WHEN ty.typname in ('int8', '_int8') THEN 64 \
WHEN ty.typname in ('numeric', '_numeric') THEN \
CASE WHEN atttypmod = -1 \
THEN null \
ELSE((atttypmod - 4) >> 16) & 65535     -- calculate the precision \
END \
WHEN ty.typname in ('float4','_float4') THEN 24 /*FLT_MANT_DIG*/ \
WHEN ty.typname in ('float8','_float8') THEN 53 /*DBL_MANT_DIG*/ \
WHEN ty.typname in ('time','_time','timetz','_timetz','timestamp','_timestamp','timestamptz','_timestamptz') THEN \
CASE WHEN atttypmod = -1 \
THEN null \
ELSE(atttypmod - 0) & 65535     -- calculate the precision \
END \
WHEN ty.typname in ('interval','_interval') THEN \
CASE WHEN atttypmod<> -1  AND strpos(format_type(ty.oid, att.atttypmod), '(') > 1 AND strpos(format_type(ty.oid, att.atttypmod), ')') > 1 THEN \
substring(format_type(ty.oid, att.atttypmod), strpos(format_type(ty.oid, att.atttypmod), '(')+1, strpos(format_type(ty.oid, att.atttypmod), ')') - strpos(format_type(ty.oid, att.atttypmod), '(') - 1 )::integer \
ELSE null \
END \
ELSE null \
END AS numeric_precision, \
CASE \
WHEN ty.typname in ('int2', '_int2', 'int4', '_int4', 'int8', '_int8') THEN 0 \
WHEN ty.typname in ('numeric', '_numeric') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 4) & 65535 \
END \
ELSE null \
END AS numeric_scale, \
CASE \
WHEN ty.typname in ('char', '_char', 'varchar', '_varchar', 'bpchar', '_bpchar') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 4) & 65535 \
END \
WHEN ty.typname in ('bit', '_bit', 'varbit', '_varbit') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 0) & 65535 \
END \
ELSE null \
END AS character_maximum_length \
FROM pg_attribute att \
JOIN pg_type ty ON ty.oid=atttypid \
LEFT JOIN pg_class pg_cl ON pg_cl.oid = att.attrelid \
LEFT JOIN pg_namespace nc ON pg_cl.relnamespace = nc.oid \
WHERE att.attnum > 0 \
AND att.attisdropped IS FALSE \
) pg on pg.nspname = c.table_schema AND pg.relname = c.table_name AND pg.attname= c.column_name \
WHERE \
c.table_schema = ? \
AND c.table_name = ? \
)as  m
metadata.query.index=select *   \
from(   \
select   \
concat_ws(   \
'.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname) as parent_object_id,   \
concat_ws('.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname,   \
i.relname) as current_object_id,   \
(select nspname from pg_namespace where oid = i.relnamespace) as table_schema,   \
t.relname     as table_name,   \
i.relname     as name,   \
case when idx.indisready = 't'   \
then true    \
else false    \
end as index_is_ready,   \
am.amname     as index_type,   \
case when idx.indisclustered = 't' then true    \
else false    \
end as is_clustered,   \
case when indexprs is not null then true    \
else false    \
end as is_function_based,   \
case when COALESCE(con.contype,'1') in('p','u') then true    \
when idx.indisunique = 't' then true    \
else false    \
end as is_unique,   \
case   \
when idx.indisvalid = 't'   \
then true    \
else false    \
end as is_valid,   \
array_to_string(i.reloptions, ',') as  r_options    \
from   \
pg_index    as idx   \
inner join pg_class  as i  on i.oid  = idx.indexrelid   \
inner join (select p.*, p.oid from pg_class p)  as t  on t.oid  = idx.indrelid   \
inner join pg_am  as am on am.oid = i.relam   \
left outer join pg_constraint as con on con.conindid = idx.indexrelid and con.confrelid = 0) a   \
where   \
is_unique = false    \
AND table_schema = ?   \
AND table_name = ?
metadata.query.index-column=select *   \
from(   \
select   \
concat_ws('.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname,   \
i.relname) as current_object_id,   \
(   \
select nspname   \
from pg_namespace   \
where oid = i.relnamespace   \
)                                 as table_schema,   \
t.relname                        as table_name,   \
i.relname                         as index_name,   \
ser.num_column                        as order_column,   \
pg_get_indexdef(idx.indexrelid, ser.num_column, true) as name,   \
case   \
when ser.indoption[ser.k-1] & 1 = 1 then 'DESC'   \
else 'ASC'   \
end                                 as order_by ,   \
case   \
when (ser.indoption[ser.k-1] & 2 = 2) then 'NULLS FIRST'   \
else 'NULLS LAST'   \
end                                 as nulls,   \
case when COALESCE(con.contype,'1') in('p','u') then true   \
else false   \
end                                 as is_unique    \
from   \
pg_index           as idx   \
inner join (   \
select ii.indexrelid as idx_id, unnest(ii.indkey) as k, ii.*, generate_subscripts(ii.indkey, 1)+1 as num_column   \
from pg_index ii   \
)                 as ser on ser.idx_id = idx.indexrelid   \
inner join pg_class         as i  on i.oid  = idx.indexrelid   \
inner join pg_class         as t  on t.oid  = idx.indrelid   \
inner join pg_am         as am on am.oid = i.relam   \
left outer join pg_constraint as con on con.conindid = idx.indexrelid and con.confrelid = 0   \
) a   \
where   \
is_unique = false                         \
AND table_schema = ?   \
AND table_name = ?   \
AND index_name = ?                         \
order by table_schema, table_name, index_name, order_column
metadata.query.trigger=select   \
concat_ws('.', event_object_schema, event_object_table) as parent_object_id,   \
concat_ws('.', event_object_schema, event_object_table, trigger_name) as current_object_id,   \
trigger_name              as name,   \
tgenabled = 'D'           as is_disabled,   \
action_timing             as before_after_instead_of,   \
action_orientation        as granularity,   \
string_agg(event_manipulation,' OR ') as trigger_event,    \
pg_get_functiondef(oid) as text   \
FROM (SELECT current_database() AS trigger_catalog,   \
pn.nspname AS trigger_schema,   \
pt.tgname AS trigger_name,   \
em.text AS event_manipulation,   \
current_database() AS event_object_catalog,   \
pn.nspname AS event_object_schema,   \
pc.relname AS event_object_table,   \
(CASE ((pt.tgtype)::integer & 1) WHEN 1 THEN 'ROW'::text ELSE 'STATEMENT'::text END) AS action_orientation,   \
(CASE ((pt.tgtype)::integer & 66) WHEN 2 THEN 'BEFORE'::text WHEN 64 THEN 'INSTEAD_OF'::text ELSE 'AFTER'::text END) AS action_timing,   \
pp.oid,   \
tgenabled,   \
("substring"(pg_get_triggerdef(pt.oid), ("position"("substring"(pg_get_triggerdef(pt.oid), 48), 'EXECUTE PROCEDURE'::text) + 47))) AS action_statement   \
FROM pg_namespace pn,   \
pg_class pc,   \
pg_trigger pt,   \
pg_proc pp,   \
pg_language pl,   \
(VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)   \
WHERE pn.oid = pc.relnamespace AND pc.oid = pt.tgrelid AND (((pt.tgtype)::integer & em.num) <> 0) AND(NOT pt.tgisinternal)   \
AND(NOT pg_is_other_temp_schema(pn.oid))   \
and pp.oid = pt.tgfoid   \
and pp.prolang = pl.oid   \
and pl.lanname NOT IN ('c','internal')   \
and pn.nspname NOT LIKE 'pg_%'   \
and pn.nspname<> 'information_schema'   \
)sub   \
where event_object_schema = ?   \
and event_object_table = ?   \
GROUP BY   \
event_object_schema,   \
event_object_table,   \
trigger_name,   \
action_orientation,   \
action_timing,   \
action_statement,oid,   \
tgenabled,   \
action_orientation
metadata.query.constraint=SELECT *    \
FROM (   \
SELECT   \
CONCAT_WS('.', tc.table_schema, tc.table_name) as parent_object_id,   \
concat_ws('.', tc.table_schema, tc.table_name, tc.constraint_name) as current_object_id,   \
tc.constraint_name as name,   \
current_database() as referenced_database,   \
tc.table_schema,   \
tc.table_name,   \
tc.constraint_schema,   \
tc.constraint_type,   \
case when tc.is_deferrable = 'YES'   \
then true   \
else false   \
end as is_deferrable,   \
case when tc.initially_deferred = 'YES'   \
then true   \
else false   \
end as is_initially_deferred,   \
case when tc.CONSTRAINT_TYPE in ('PRIMARY KEY', 'FOREIGN KEY', 'CHECK') then tc.CONSTRAINT_TYPE   \
when tc.CONSTRAINT_TYPE = 'UNIQUE' then 'UNIQUE KEY'   \
else null   \
end as constraint_type_desc,   \
case when tc.CONSTRAINT_TYPE = 'CHECK'   \
then ( select pg_get_constraintdef(c.oid)   \
from pg_constraint as c   \
join pg_namespace s on s.oid = c.connamespace   \
where s.nspname = tc.constraint_schema   \
and c.conname = tc.constraint_name )   \
else null   \
end as check_clause,   \
rc.referenced_table_schema,   \
rc.referenced_table_name,   \
rc.referenced_constraint_schema,   \
rc.referenced_constraint_name,   \
case when rc.match_option = 'NONE' then 'SIMPLE' else rc.match_option end as match_option,   \
rc.update_rule,   \
rc.delete_rule,   \
case when iprop.indisclustered = 't'   \
then true   \
else false    \
end as is_clustered,   \
case   \
when iprop.indisvalid = 't'   \
then true    \
else false    \
end as is_valid,   \
iprop.r_options as r_options    \
from   \
(   \
SELECT nc.nspname::information_schema.sql_identifier          AS constraint_schema,   \
c.conname::information_schema.sql_identifier           AS constraint_name,   \
nr.nspname::information_schema.sql_identifier          AS table_schema,   \
r.relname::information_schema.sql_identifier           AS table_name,   \
CASE c.contype   \
WHEN 'c'::"char" THEN 'CHECK'::text   \
WHEN 'f'::"char" THEN 'FOREIGN KEY'::text   \
WHEN 'p'::"char" THEN 'PRIMARY KEY'::text   \
WHEN 'u'::"char" THEN 'UNIQUE'::text   \
ELSE NULL::text   \
END::information_schema.character_data             AS constraint_type,   \
CASE   \
WHEN c.condeferrable THEN 'YES'::text   \
ELSE 'NO'::text   \
END::information_schema.yes_or_no AS is_deferrable,   \
CASE   \
WHEN c.condeferred THEN 'YES'::text   \
ELSE 'NO'::text   \
END::information_schema.yes_or_no AS initially_deferred,   \
'YES'::character varying::information_schema.yes_or_no AS enforced   \
FROM pg_namespace nc,   \
pg_namespace nr,   \
pg_constraint c,   \
pg_class r   \
WHERE nc.oid = c.connamespace   \
AND nr.oid = r.relnamespace   \
AND c.conrelid = r.oid   \
AND (c.contype<> ALL (ARRAY['t'::"char", 'x'::"char"]))   \
AND(r.relkind = ANY(ARRAY['r'::"char", 'p'::"char"]))   \
AND NOT pg_is_other_temp_schema(nr.oid)   \
UNION ALL   \
SELECT nr.nspname::information_schema.sql_identifier                 AS constraint_schema,   \
(((((nr.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) ||   \
'_not_null'::text)::information_schema.sql_identifier AS constraint_name,   \
nr.nspname::information_schema.sql_identifier AS table_schema,   \
r.relname::information_schema.sql_identifier AS table_name,   \
'CHECK'::character varying::information_schema.character_data AS constraint_type,   \
'NO'::character varying::information_schema.yes_or_no AS is_deferrable,   \
'NO'::character varying::information_schema.yes_or_no AS initially_deferred,   \
'YES'::character varying::information_schema.yes_or_no AS enforced   \
FROM pg_namespace nr,   \
pg_class r,   \
pg_attribute a   \
WHERE nr.oid = r.relnamespace   \
AND r.oid = a.attrelid   \
AND a.attnotnull   \
AND a.attnum > 0   \
AND NOT a.attisdropped   \
AND (r.relkind = ANY(ARRAY['r'::"char", 'p'::"char"]))   \
AND NOT pg_is_other_temp_schema(nr.oid)   \
) tc   \
left outer join(select   \
r.constraint_schema   \
, r.constraint_name   \
, ctu.table_schema referenced_table_schema   \
, ctu.table_name referenced_table_name   \
, r.unique_constraint_schema referenced_constraint_schema   \
, r.unique_constraint_name referenced_constraint_name   \
, r.match_option   \
, r.update_rule   \
, r.delete_rule   \
from (   \
SELECT ncon.nspname::information_schema.sql_identifier AS constraint_schema,   \
con.conname::information_schema.sql_identifier AS constraint_name,   \
npkc.nspname::information_schema.sql_identifier AS unique_constraint_schema,   \
pkc.conname::information_schema.sql_identifier AS unique_constraint_name,   \
CASE con.confmatchtype   \
WHEN 'f'::"char" THEN 'FULL'::text   \
WHEN 'p'::"char" THEN 'PARTIAL'::text   \
WHEN 's'::"char" THEN 'NONE'::text   \
ELSE NULL::text   \
END::information_schema.character_data AS match_option,   \
CASE con.confupdtype   \
WHEN 'c'::"char" THEN 'CASCADE'::text   \
WHEN 'n'::"char" THEN 'SET NULL'::text   \
WHEN 'd'::"char" THEN 'SET DEFAULT'::text   \
WHEN 'r'::"char" THEN 'RESTRICT'::text   \
WHEN 'a'::"char" THEN 'NO ACTION'::text   \
ELSE NULL::text   \
END::information_schema.character_data AS update_rule,   \
CASE con.confdeltype   \
WHEN 'c'::"char" THEN 'CASCADE'::text   \
WHEN 'n'::"char" THEN 'SET NULL'::text   \
WHEN 'd'::"char" THEN 'SET DEFAULT'::text   \
WHEN 'r'::"char" THEN 'RESTRICT'::text   \
WHEN 'a'::"char" THEN 'NO ACTION'::text   \
ELSE NULL::text   \
END::information_schema.character_data AS delete_rule   \
FROM pg_namespace ncon   \
JOIN pg_constraint con ON ncon.oid = con.connamespace   \
JOIN pg_class c ON con.conrelid = c.oid AND con.contype = 'f'::"char"   \
LEFT JOIN pg_depend d1 ON d1.objid = con.oid AND d1.classid = 'pg_constraint'::regclass::oid AND   \
d1.refclassid = 'pg_class'::regclass::oid AND d1.refobjsubid = 0   \
LEFT JOIN pg_depend d2   \
ON d2.refclassid = 'pg_constraint'::regclass::oid AND d2.classid = 'pg_class'::regclass::oid AND   \
d2.objid = d1.refobjid AND d2.objsubid = 0 AND d2.deptype = 'i'::"char"   \
LEFT JOIN pg_constraint pkc   \
ON pkc.oid = d2.refobjid AND (pkc.contype = ANY(ARRAY['p'::"char", 'u'::"char"])) AND   \
pkc.conrelid = con.confrelid   \
LEFT JOIN pg_namespace npkc ON pkc.connamespace = npkc.oid   \
) r   \
inner join   \
(   \
SELECT nr.nspname::information_schema.sql_identifier AS table_schema,   \
r.relname::information_schema.sql_identifier AS table_name,   \
nc.nspname::information_schema.sql_identifier AS constraint_schema,   \
c.conname::information_schema.sql_identifier AS constraint_name   \
FROM pg_constraint c,   \
pg_namespace nc,   \
pg_class r,   \
pg_namespace nr   \
WHERE c.connamespace = nc.oid   \
AND r.relnamespace = nr.oid   \
AND (c.contype = 'f'::"char" AND c.confrelid = r.oid   \
OR (c.contype = ANY(ARRAY['p'::"char", 'u'::"char"]))   \
AND c.conrelid = r.oid)   \
AND(r.relkind = ANY(ARRAY['r'::"char", 'p'::"char"]))   \
)   \
ctu on(r.constraint_name = ctu.constraint_name and r.constraint_schema= ctu.constraint_schema)   \
) rc on(rc.constraint_name = tc.constraint_name and rc.constraint_schema= tc.constraint_schema)   \
left join   \
(select t.relname table_name,   \
idx.indisclustered,   \
idx.indisvalid,   \
array_to_string(i.reloptions, ',') as  r_options,   \
i.relname as constraint_name,   \
(select nspname from pg_namespace ns where t.relnamespace=ns.oid) as table_schame   \
from   \
pg_index    as idx   \
inner join pg_class  as i on i.oid  = idx.indexrelid    \
inner join pg_class  as t on t.oid  = idx.indrelid   \
inner join pg_am  as am on am.oid = i.relam   \
left outer join pg_constraint as con on con.conindid = idx.indexrelid and con.confrelid = 0   \
) iprop on    iprop.table_name = tc.table_name and iprop.constraint_name = tc.constraint_name and iprop.table_schame = tc.table_schema   \
) GLB   \
WHERE GLB.constraint_type_desc = ?   \
AND GLB.table_schema = ?   \
AND GLB.table_name = ?
metadata.query.constraint-column=select   \
concat_ws('.', cols.table_schema, cols.table_name, cols.constraint_name) as current_object_id,   \
cols.table_schema,   \
cols.table_name,   \
cols.constraint_schema,   \
cols.constraint_name,   \
cols.column_name as name,   \
cols.ordinal_position,   \
cols.position_in_unique_constraint,   \
nfr.nspname as referenced_table_schema,   \
fr.relname as referenced_table_name,   \
fa.attname as column_in_unique_constraint,   \
cols.constraint_type as constraint_type_desc    \
from (   \
select ss.table_schema,   \
ss.table_name,   \
ss.constraint_schema,   \
ss.constraint_name,   \
a.attname as column_name,   \
(ss.conkey_array).n as ordinal_position,   \
case   \
when ss.contype = 'f'   \
then information_schema._pg_index_position(ss.conindid, ss.confkey [(ss.conkey_array).n])   \
else null   \
end as position_in_unique_constraint,   \
ss.confrelid,   \
case   \
when ss.contype = 'f'   \
then ss.confkey [(ss.conkey_array).n]   \
else null   \
end as ref_col_pos,   \
ss.constraint_type   \
from pg_attribute a,   \
(   \
select nr.nspname as table_schema   \
, r.relname as table_name   \
, nc.nspname as constraint_schema   \
, c.conname as constraint_name   \
, r.oid as roid   \
, r.relowner   \
, c.oid as coid   \
, c.contype   \
, c.conindid   \
, c.confkey   \
, c.confrelid   \
, c.conkey   \
, information_schema._pg_expandarray(c.conkey) as conkey_array   \
, CASE   \
WHEN c.contype = 'c' THEN 'CHECK'   \
WHEN c.contype = 'p' THEN 'PRIMARY KEY'   \
WHEN c.contype = 'f' THEN 'FOREIGN KEY'   \
WHEN c.contype = 'u' THEN 'UNIQUE KEY'   \
ELSE NULL   \
END as constraint_type   \
from pg_namespace nr   \
, pg_class r   \
, pg_namespace nc   \
, pg_constraint c   \
where nr.oid = r.relnamespace   \
and r.oid = c.conrelid   \
and nc.oid = c.connamespace   \
and c.contype in ('p', 'u', 'f')   \
and r.relkind = 'r'   \
and (not pg_is_other_temp_schema(nr.oid))   \
) as ss   \
where ss.roid = a.attrelid   \
and a.attnum = (ss.conkey_array).x   \
and not a.attisdropped   \
) cols   \
left join pg_class fr on cols.confrelid = fr.oid   \
left join pg_namespace as nfr on nfr.oid = fr.relnamespace   \
left join pg_attribute fa on fr.oid = fa.attrelid   \
and fa.attnum = cols.ref_col_pos   \
and not fa.attisdropped   \
where  cols.table_schema = ?   \
and cols.table_name = ?   \
and cols.constraint_name = ?   \
order by cols.table_schema, cols.table_name, cols.constraint_schema, cols.constraint_name, cols.ordinal_position
metadata.query.check-constraint=SELECT * FROM   \
(select \
concat_ws('.', constraint_schema, table_name) as parent_object_id,    \
constraint_schema,   \
table_name as parent_name,      \
concat_ws('.', constraint_schema, table_name, constraint_name) as current_object_id,      \
constraint_name as name,      \
pg_get_constraintdef(pc.oid) condition_definition        \
from   (SELECT nc.nspname AS constraint_schema,      \
c.conname AS constraint_name,      \
r.relname AS table_name,      \
CASE c.contype      \
WHEN 'c'::"char" THEN 'CHECK'::text      \
WHEN 'f'::"char" THEN 'FOREIGN KEY'::text      \
WHEN 'p'::"char" THEN 'PRIMARY KEY'::text      \
WHEN 'u'::"char" THEN 'UNIQUE'::text      \
ELSE NULL::text      \
END AS constraint_type      \
FROM pg_namespace nc,      \
pg_namespace nr,     \
pg_constraint c,      \
pg_class r      \
WHERE nc.oid = c.connamespace AND nr.oid = r.relnamespace AND c.conrelid = r.oid AND c.contype = 'c'::"char" AND r.relkind = 'r'::"char" AND NOT pg_is_other_temp_schema(nr.oid)    \
UNION ALL      \
SELECT nr.nspname AS constraint_schema,      \
((((((nr.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text) AS constraint_name,      \
r.relname AS table_name,      \
'CHECK'::character varying AS constraint_type      \
FROM pg_namespace nr,      \
pg_class r,      \
pg_attribute a      \
WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnotnull AND a.attnum > 0 AND NOT a.attisdropped AND r.relkind = 'r'::"char" AND NOT pg_is_other_temp_schema(nr.oid)      \
) tc,      \
pg_constraint pc,      \
pg_namespace ns,      \
pg_class cl      \
where   \
tc.constraint_type = 'CHECK'      \
AND pc.connamespace = ns.oid      \
AND pc.conrelid = cl.oid      \
AND pc.conrelid<>0      \
AND pc.contypid=0      \
AND tc.constraint_name = pc.conname      \
AND tc.constraint_schema = ns.nspname      \
AND tc.table_name = cl.relname      \
UNION   \
select      \
concat_ws('.', constraint_schema, domain_name) as parent_object_id,      \
constraint_schema,   \
domain_name as parent_name,      \
concat_ws('.', constraint_schema, domain_name, constraint_name) as current_object_id,      \
constraint_name as name,      \
pg_get_constraintdef(pc.oid) condef       \
from   (SELECT rs.nspname AS constraint_schema,      \
con.conname AS constraint_name,      \
n.nspname AS domain_schema,      \
t.typname AS domain_name      \
FROM pg_namespace rs, pg_namespace n, pg_constraint con, pg_type t      \
WHERE rs.oid = con.connamespace AND n.oid = t.typnamespace AND t.oid = con.contypid) dc,      \
pg_constraint pc,      \
pg_namespace ns,      \
pg_type pt      \
where pc.connamespace = ns.oid      \
AND pc.contypid = pt.oid      \
AND dc.constraint_name= pc.conname      \
AND dc.constraint_schema = ns.nspname      \
AND dc.domain_name = pt.typname      \
AND pc.conrelid=0      \
AND pc.contypid<>0      \
) GLB      \
where   \
GLB.constraint_schema = ?      \
AND GLB.parent_name = ?
metadata.query.parameter=select * from (      \
select      \
concat_ws('.', prc.pronamespace, prc.oid) as parent_object_id,      \
concat_ws('.', prc.pronamespace, prc.oid, prm.ordinal_position) as current_object_id,      \
sch.nspname            as schema_name,      \
prc.proname            as function_name,      \
COALESCE(prm.parameter_name, concat('@p', prm.ordinal_position))     as name,      \
false 			            as is_returns,      \
case when prm.udt_name in ('int2vector', 'oidvector') and prm.data_type='ARRAY' then prm.udt_name      \
when prm.udt_name in ('_int2vector', '_oidvector') and prm.data_type='ARRAY' then concat(substring(prm.udt_name from 2),'[]')      \
when prm.data_type<>'ARRAY' then      \
case when prm.data_type = 'USER-DEFINED'      \
then prm.udt_name else prm.data_type end      \
else      \
concat(coalesce(      \
(SELECT      \
CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text      \
WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer) ELSE 'USER-DEFINED'::text      \
END AS data_type      \
FROM pg_type t,      \
pg_namespace nt      \
WHERE t.typnamespace = nt.oid      \
AND concat('_',t.typname) = prm.udt_name limit 1), prm.data_type),'[]')      \
end as type_name,      \
prm.parameter_mode     as argument_mode,      \
case when prm.data_type = 'USER-DEFINED' then prm.udt_schema else null end as domain_schema,      \
case when prm.data_type = 'USER-DEFINED' then true else false end as is_udt,      \
current_database() as database,      \
prm.ordinal_position   as argument_order       \
from      \
pg_proc                 as prc      \
join ( SELECT NULLIF(ss.proargnames[(ss.x).n], ''::text) AS parameter_name,      \
CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text      \
WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer) ELSE 'USER-DEFINED'::text      \
END AS data_type,      \
((ss.x).n)::information_schema.cardinal_number AS ordinal_position,      \
CASE WHEN (ss.proargmodes IS NULL) THEN 'IN'::text      \
WHEN (ss.proargmodes[(ss.x).n] = 'i'::"char") THEN 'IN'::text      \
WHEN(ss.proargmodes[(ss.x).n] = 'o'::"char") THEN 'OUT'::text      \
WHEN(ss.proargmodes[(ss.x).n] = 'b'::"char") THEN 'INOUT'::text      \
WHEN(ss.proargmodes[(ss.x).n] = 'v'::"char") THEN 'IN'::text      \
WHEN(ss.proargmodes[(ss.x).n] = 't'::"char") THEN 'OUT'::text      \
ELSE NULL::text      \
END AS parameter_mode,      \
t.typname AS udt_name,      \
nt.nspname AS udt_schema,      \
(((ss.proname)::text || '_'::text) || (ss.p_oid)::text) AS specific_name      \
FROM pg_type t,      \
pg_namespace nt,      \
( SELECT n.nspname AS n_nspname, p.proname, p.oid AS p_oid, p.proowner, p.proargnames, p.proargmodes,      \
information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x      \
FROM pg_namespace n, pg_proc p WHERE n.oid = p.pronamespace) ss      \
WHERE t.oid = (ss.x).x AND t.typnamespace = nt.oid) as prm      \
on prm.specific_name = concat_ws('_', prc.proname, prc.oid)      \
join pg_namespace       as sch on sch.oid = prc.pronamespace      \
union all      \
select      \
concat_ws('.', prc.pronamespace, prc.oid) as parent_object_id,      \
concat_ws('.', prc.pronamespace, prc.oid, '0') as current_object_id,      \
sch.nspname            as schema_name,      \
prc.proname            as function_name,      \
NULL                   as name,      \
true 			            as is_returns,      \
replace(format_type(typ.oid, null), coalesce(sch_domain.nspname, '')||'.','') AS type_name,      \
'OUT'                  as argument_mode,      \
case when sch_domain.nspname in ('pg_catalog', 'information_schema')      \
then null else sch_domain.nspname      \
end as domain_schema,      \
case when sch_domain.nspname in ('pg_catalog', 'information_schema')      \
then false else true      \
end as is_udt,      \
current_database() as database,      \
0                  as argument_order       \
from      pg_proc                 as prc      \
join pg_namespace       as sch on sch.oid = prc.pronamespace      \
join pg_type            as typ on typ.oid = prc.prorettype      \
join pg_namespace       as sch_domain on typ.typnamespace = sch_domain.oid      \
where prc.prorettype::regtype::text not in ('void', 'refcursor', 'record')      \
)a      \
where      \
schema_name = ? and function_name = ?