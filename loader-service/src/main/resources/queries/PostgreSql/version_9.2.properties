metadata.query.server=SELECT\
   (substring(version(), '[0-9.]+')) AS version, \
   pg_postmaster_start_time()::VARCHAR AS uuid;
metadata.query.database=SELECT d.datname as name, d.datcollate as collation, \
  COALESCE(current_schema(), 'public') as default_schema \
  FROM pg_database d \
  WHERE d.datistemplate = false and d.datname = current_database(); 
metadata.query.schema=select current_database() AS parent_object_id, n.nspname as current_object_id, n.nspname as name, \
  CASE WHEN n.nspname like 'pg\_%' or n.nspname = 'information_schema' THEN 1 ELSE 0 END AS is_system \
  from pg_namespace n \
  where current_database() = ?
metadata.query.extension=select current_database() as parent_object_id, pn.nspname AS schema_name, pe.extname as current_object_id,\
  \ pe.extname as name, pe.extowner, pe.extnamespace, pe.extrelocatable, pe.extversion \
  from pg_extension pe, pg_namespace pn \
  where pe.extnamespace=pn.oid and current_database() = ?
metadata.query.table=select nc.nspname AS parent_object_id, c.relname AS name, \
  concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN t.typname IS NOT NULL THEN  1 ELSE 0 END AS is_typed_table \
  from ((pg_namespace nc JOIN pg_class c ON ((nc.oid = c.relnamespace))) \
  LEFT JOIN (pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid))) \
  where (NOT pg_is_other_temp_schema(nc.oid)) AND (c.relkind = 'r'::"char") AND current_database() = ? AND nc.nspname = ?
metadata.query.view=select c.relname AS name, concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 1 ELSE 0 END as is_updatable, \
  pg_get_viewdef(c.oid) AS text \
  from pg_namespace nc, pg_class c \
  where (c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
  AND current_database() = ? AND nc.nspname = ?
metadata.query.materialized-view=select schemaname as parent_object_id,matviewname as name, \
  schemaname || '.' || matviewname AS current_object_id, ispopulated as is_updatable, hasindexes as has_indexes, \
  definition as text \
  from pg_matviews where current_database() = ? and schemaname = ?
metadata.query.procedure=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.aggregate-function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and prc.proisagg = true \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.sequence=select \
        c.relname AS current_object_id, \
        false as is_udt, \
        c.relname AS name, \
        'bigint'::character varying AS type_name,  \
        p.start_value AS start_value, \
        p.minimum_value AS minimum_value, \
        p.maximum_value AS character_maximum_length, \
        p.increment AS increment, \
        64::information_schema.cardinal_number AS numeric_precision, \
        0::information_schema.cardinal_number AS numeric_scale, \
        CASE WHEN (CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) = 'YES' THEN true ELSE false END as cycle_option \
        ,false as cache_flag \
        ,null as cache_size \
        ,null as last_value  \
    from    pg_namespace nc, \
        pg_class c, \
        LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
    where \
    (c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
        and current_database() = ? \
        and nc.nspname = ?