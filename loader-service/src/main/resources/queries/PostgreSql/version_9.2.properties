metadata.query.server=SELECT\
   (substring(version(), '[0-9.]+')) AS version, \
   pg_postmaster_start_time()::VARCHAR AS uuid;
metadata.query.database=SELECT d.datname as name, d.datcollate as collation, \
  COALESCE(current_schema(), 'public') as default_schema \
  FROM pg_database d \
  WHERE d.datistemplate = false and d.datname = current_database(); 
metadata.query.schema=select current_database() AS parent_object_id, n.nspname as current_object_id, n.nspname as name, \
  CASE WHEN n.nspname like 'pg\_%' or n.nspname = 'information_schema' THEN 1 ELSE 0 END AS is_system \
  from pg_namespace n \
  where current_database() = ?
metadata.query.extension=select current_database() as parent_object_id, pn.nspname AS schema_name, pe.extname as current_object_id,\
  \ pe.extname as name, pe.extowner, pe.extnamespace, pe.extrelocatable, pe.extversion \
  from pg_extension pe, pg_namespace pn \
  where pe.extnamespace=pn.oid and current_database() = ?
metadata.query.table=select nc.nspname AS parent_object_id, c.relname AS name, \
  concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN t.typname IS NOT NULL THEN  1 ELSE 0 END AS is_typed_table \
  from ((pg_namespace nc JOIN pg_class c ON ((nc.oid = c.relnamespace))) \
  LEFT JOIN (pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid))) \
  where (NOT pg_is_other_temp_schema(nc.oid)) AND (c.relkind = 'r'::"char") AND current_database() = ? AND nc.nspname = ?
metadata.query.view=select c.relname AS name, concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 1 ELSE 0 END as is_updatable, \
  pg_get_viewdef(c.oid) AS text \
  from pg_namespace nc, pg_class c \
  where (c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
  AND current_database() = ? AND nc.nspname = ?
metadata.query.materialized-view=select schemaname as parent_object_id,matviewname as name, \
  schemaname || '.' || matviewname AS current_object_id, ispopulated as is_updatable, hasindexes as has_indexes, \
  definition as text \
  from pg_matviews where current_database() = ? and schemaname = ?
metadata.query.procedure=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.aggregate-function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and prc.proisagg = true \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.sequence=select \
        c.relname AS current_object_id, \
        false as is_udt, \
        c.relname AS name, \
        'bigint'::character varying AS type_name,  \
        p.start_value AS start_value, \
        p.minimum_value AS minimum_value, \
        p.maximum_value AS character_maximum_length, \
        p.increment AS increment, \
        64::information_schema.cardinal_number AS numeric_precision, \
        0::information_schema.cardinal_number AS numeric_scale, \
        CASE WHEN (CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) = 'YES' THEN true ELSE false END as cycle_option \
        ,false as cache_flag \
        ,null as cache_size \
        ,null as last_value  \
    from    pg_namespace nc, \
        pg_class c, \
        LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
    where \
    (c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
        and current_database() = ? \
        and nc.nspname = ?
metadata.query.udt=SELECT \
        m.parent_object_id, \
        m.current_object_id, \
        m.name, \
        m.type_name, \
        m.udt_name, \
        m.udt_schema, \
        coalesce(m.character_maximum_length, m.character_maximum_length_calc) as character_maximum_length, \
        case when trim(m.parent_object_id) is null then false else true end as is_udt, \
        m.domain_schema, \
        m.database, \
        m.numeric_precision, \
        m.numeric_scale, \
        m.allow_nulls, \
        m.is_domain, \
        m.is_type_enum \
    FROM ( \
            SELECT \
                ns.nspname as parent_object_id, \
                current_database() as database, \
                concat_ws('.', ns.nspname, t.typname ) as current_object_id, \
                t.typname as name, \
                CASE \
                WHEN c.data_type = 'USER-DEFINED' \
                THEN replace(replace(format_Type(t.typbasetype,null),c.udt_schema||'.',''),'[]','') \
                ELSE c.data_type \
                END  as type_name, \
                c.udt_name, \
                c.udt_schema, \
                COALESCE(c.domain_schema, '') as domain_schema, \
                c.character_maximum_length, \
                coalesce(c.numeric_precision, c.datetime_precision) as numeric_precision, \
                c.numeric_scale, \
                case when t.typnotnull = 't' then false else true end as allow_nulls, \
                CASE WHEN c.udt_name in ('_char', '_varchar', '_bpchar') THEN \
                CASE WHEN t.typtypmod < 0 THEN null \
                ELSE (t.typtypmod - 4) & 65535 \
                END \
                ELSE null \
                END AS character_maximum_length_calc, \
                CASE WHEN (UPPER(t.typinput::varchar) = 'DOMAIN_IN') THEN true ELSE false END as is_domain, \
                CASE WHEN (upper(t.typinput::varchar) = 'ENUM_IN') THEN true ELSE false END as is_type_enum \
            FROM pg_catalog.pg_type t \
                LEFT JOIN pg_catalog.pg_namespace ns ON t.typnamespace = ns.oid \
                LEFT JOIN information_schema.domains c ON c.domain_name = t.typname and c.domain_schema = ns.nspname \
            WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) \
            AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid) \
            and current_database() = ? \
            AND ns.nspname = ? \
    ) m
metadata.query.column=select \
m.parent_object_id, \
m.table_name, \
m.name, \
m.current_object_id, \
m.database, \
case when coalesce(m.domain_schema, m.udt_schema) is not null \
then m.typname \
when strpos(m.displaytypname_full, '(')>0 and strpos(m.displaytypname_full, ')')>0 then \
CONCAT(left(m.displaytypname_full, strpos(m.displaytypname_full, '(')-1), right(m.displaytypname_full, length(m.displaytypname_full) - strpos(m.displaytypname_full, ')'))) \
else m.displaytypname_full \
end type_name, \
m.typname as type_name_alias, \
m.character_maximum_length, \
coalesce(m.numeric_precision) as numeric_precision, \
m.numeric_scale, m.is_identity, \
case when m.table_type = 'BASE TABLE' then m.is_nullable else null end as is_nullable, \
case when coalesce(m.domain_schema, m.udt_schema) is null then false else true end as is_udt, \
m.domain_schema, m.udt_schema, \
m.is_generated, m.column_default, m.ordinal_position, m.collation_name, m.minimum_value, m.increment  \
from \
( select \
c.table_name, \
c.domain_schema, \
CASE WHEN c.udt_schema NOT IN ('pg_catalog') THEN  c.udt_schema ELSE NULL END AS udt_schema, \
c.column_name as name, \
CONCAT_WS('.', c.table_schema, c.table_name) as parent_object_id, \
CONCAT_WS('.', c.table_schema, c.table_name, c.column_name) as current_object_id, \
current_database() as database, \
replace(format_type(pg.oid,pg.atttypmod), coalesce(coalesce(c.domain_schema, c.udt_schema), '')||'.','') AS displaytypname_full, \
pg.typname, \
coalesce(c.character_maximum_length, pg.character_maximum_length) as character_maximum_length, \
coalesce(c.numeric_precision, pg.numeric_precision, c.datetime_precision) as numeric_precision, \
coalesce(c.numeric_scale, pg.numeric_scale) as numeric_scale, \
case when c.is_identity= 'NO' then false \
else true \
end as is_identity, \
case when c.is_nullable= 'NO' then false \
else true \
end as is_nullable, \
is_generated, \
c.column_default, \
c.ordinal_position, \
collation_name, \
seq.minimum_value::Decimal, \
seq.increment::Decimal, \
c.table_catalog, \
c.table_schema, \
(SELECT CASE \
WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text \
WHEN (cc.relkind = 'r'::"char") THEN 'BASE TABLE'::text \
WHEN(cc.relkind = 'v'::"char") THEN 'VIEW'::text \
WHEN(cc.relkind = 'f'::"char") THEN 'FOREIGN TABLE'::text \
ELSE NULL::text \
END AS table_type \
FROM pg_namespace nc \
JOIN pg_class cc ON nc.oid = cc.relnamespace \
WHERE cc.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char"]) \
AND NOT pg_is_other_temp_schema(nc.oid) \
AND current_database()= c.table_catalog \
AND nc.nspname= c.table_schema \
AND cc.relname= c.table_name) table_type \
from \
( \
SELECT current_database() AS table_catalog, \
nc.nspname AS table_schema, \
c.relname AS table_name, \
a.attname AS column_name, \
a.attnum AS ordinal_position, \
pg_get_expr(ad.adbin, ad.adrelid) AS column_default, \
CASE WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text \
ELSE 'YES'::text END AS is_nullable, \
information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS character_maximum_length, \
information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS numeric_precision, \
information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS numeric_scale, \
information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS datetime_precision, \
nco.nspname AS collation_schema, \
co.collname AS collation_name, \
CASE \
WHEN(t.typtype = 'd'::"char") THEN nt.nspname \
ELSE NULL::name \
END AS domain_schema, \
COALESCE(nbt.nspname, nt.nspname) AS udt_schema, \
'NO'::character varying AS is_identity, \
'NEVER'::character varying AS is_generated \
FROM(((((pg_attribute a \
LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND(a.attnum = ad.adnum)))) \
JOIN(pg_class c \
JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON((a.attrelid = c.oid))) \
JOIN(pg_type t \
JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON((a.atttypid = t.oid))) \
LEFT JOIN(pg_type bt \
JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON(((t.typtype = 'd'::"char") AND(t.typbasetype = bt.oid)))) \
LEFT JOIN(pg_collation co \
JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON(((a.attcollation = co.oid) AND((nco.nspname<> 'pg_catalog'::name) OR(co.collname<> 'default'::name))))) \
WHERE(NOT pg_is_other_temp_schema(nc.oid)) AND(a.attnum > 0) AND(NOT a.attisdropped) AND(c.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char", 'm'::"char"])) \
) c \
left outer join \
(select substring(tmp_seq.tmp_name_seq, tmp_seq.pos_from, tmp_seq.pos_end-tmp_seq.pos_from+1) seq_name, tmp_seq.column_default \
,tmp_seq.table_catalog, tmp_seq.table_schema, tmp_seq.table_name, tmp_seq.column_name, tmp_sequences_schema, i_seq.* \
from \
(SELECT replace(pg_get_expr(ad.adbin, ad.adrelid), '"', '') tmp_name_seq, \
case when strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')>0 \
Then strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')+1 \
else strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), 'nextval(')+9 end as pos_from, \
strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '::')-2 as pos_end, \
pg_get_expr(ad.adbin, ad.adrelid) column_default, \
current_database() table_catalog, \
nc.nspname table_schema, \
c.relname table_name, \
a.attname column_name, \
case when strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')>0 \
Then substring(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), 10,strpos(replace(pg_get_expr(ad.adbin, ad.adrelid), '"', ''), '.')-10) \
else nc.nspname end as tmp_sequences_schema \
FROM(pg_attribute a LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum) \
JOIN \
(pg_class c JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid \
WHERE (NOT pg_is_other_temp_schema(nc.oid)) AND(a.attnum > 0) AND(NOT a.attisdropped) AND(c.relkind = ANY(ARRAY['r'::"char", 'v'::"char", 'f'::"char"])) \
AND strpos((pg_get_expr(ad.adbin, ad.adrelid)), 'nextval(') > 0 \
) tmp_seq, \
(SELECT current_database() AS sequence_catalog, \
nc.nspname AS sequence_schema, \
c.relname AS sequence_name, \
'bigint'::character varying AS data_type, \
64::information_schema.cardinal_number AS numeric_precision, \
2::information_schema.cardinal_number AS numeric_precision_radix, \
0::information_schema.cardinal_number AS numeric_scale, \
p.start_value AS start_value, \
p.minimum_value AS minimum_value, \
p.maximum_value AS maximum_value, \
p.increment AS increment, \
(CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) AS cycle_option \
FROM pg_namespace nc, pg_class c, \
LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
WHERE(c.relnamespace = nc.oid) AND(c.relkind = 'S'::"char") AND(NOT pg_is_other_temp_schema(nc.oid)) \
) i_seq \
where substring(tmp_seq.tmp_name_seq, tmp_seq.pos_from, tmp_seq.pos_end-tmp_seq.pos_from+1)=i_seq.sequence_name \
and i_seq.sequence_catalog = tmp_seq.table_catalog \
and i_seq.sequence_schema = tmp_seq.tmp_sequences_schema \
) seq on  c.table_catalog = seq.table_catalog \
and c.table_schema = seq.table_schema \
and c.table_name = seq.table_name \
and c.column_name = seq.column_name \
left outer join \
(SELECT ty.oid, att.atttypmod, \
ty.typname, \
nc.nspname , pg_cl.relname, att.attname, \
CASE WHEN ty.typname in ('int2', '_int2') THEN 16 \
WHEN ty.typname in ('int4', '_int4') THEN 32 \
WHEN ty.typname in ('int8', '_int8') THEN 64 \
WHEN ty.typname in ('numeric', '_numeric') THEN \
CASE WHEN atttypmod = -1 \
THEN null \
ELSE((atttypmod - 4) >> 16) & 65535     -- calculate the precision \
END \
WHEN ty.typname in ('float4','_float4') THEN 24 /*FLT_MANT_DIG*/ \
WHEN ty.typname in ('float8','_float8') THEN 53 /*DBL_MANT_DIG*/ \
WHEN ty.typname in ('time','_time','timetz','_timetz','timestamp','_timestamp','timestamptz','_timestamptz') THEN \
CASE WHEN atttypmod = -1 \
THEN null \
ELSE(atttypmod - 0) & 65535     -- calculate the precision \
END \
WHEN ty.typname in ('interval','_interval') THEN \
CASE WHEN atttypmod<> -1  AND strpos(format_type(ty.oid, att.atttypmod), '(') > 1 AND strpos(format_type(ty.oid, att.atttypmod), ')') > 1 THEN \
substring(format_type(ty.oid, att.atttypmod), strpos(format_type(ty.oid, att.atttypmod), '(')+1, strpos(format_type(ty.oid, att.atttypmod), ')') - strpos(format_type(ty.oid, att.atttypmod), '(') - 1 )::integer \
ELSE null \
END \
ELSE null \
END AS numeric_precision, \
CASE \
WHEN ty.typname in ('int2', '_int2', 'int4', '_int4', 'int8', '_int8') THEN 0 \
WHEN ty.typname in ('numeric', '_numeric') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 4) & 65535 \
END \
ELSE null \
END AS numeric_scale, \
CASE \
WHEN ty.typname in ('char', '_char', 'varchar', '_varchar', 'bpchar', '_bpchar') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 4) & 65535 \
END \
WHEN ty.typname in ('bit', '_bit', 'varbit', '_varbit') THEN \
CASE \
WHEN atttypmod = -1 THEN null \
ELSE(atttypmod - 0) & 65535 \
END \
ELSE null \
END AS character_maximum_length \
FROM pg_attribute att \
JOIN pg_type ty ON ty.oid=atttypid \
LEFT JOIN pg_class pg_cl ON pg_cl.oid = att.attrelid \
LEFT JOIN pg_namespace nc ON pg_cl.relnamespace = nc.oid \
WHERE att.attnum > 0 \
AND att.attisdropped IS FALSE \
) pg on pg.nspname = c.table_schema AND pg.relname = c.table_name AND pg.attname= c.column_name \
WHERE \
c.table_schema = ? \
AND c.table_name = ? \
)as  m
metadata.query.index=select *   \
from(   \
select   \
concat_ws(   \
'.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname) as parent_object_id,   \
concat_ws('.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname,   \
i.relname) as current_object_id,   \
(select nspname from pg_namespace where oid = i.relnamespace) as table_schema,   \
t.relname     as table_name,   \
i.relname     as name,   \
case when idx.indisready = 't'   \
then true    \
else false    \
end as index_is_ready,   \
am.amname     as index_type,   \
case when idx.indisclustered = 't' then true    \
else false    \
end as is_clustered,   \
case when indexprs is not null then true    \
else false    \
end as is_function_based,   \
case when COALESCE(con.contype,'1') in('p','u') then true    \
when idx.indisunique = 't' then true    \
else false    \
end as is_unique,   \
case   \
when idx.indisvalid = 't'   \
then true    \
else false    \
end as is_valid,   \
array_to_string(i.reloptions, ',') as  r_options    \
from   \
pg_index    as idx   \
inner join pg_class  as i  on i.oid  = idx.indexrelid   \
inner join (select p.*, p.oid from pg_class p)  as t  on t.oid  = idx.indrelid   \
inner join pg_am  as am on am.oid = i.relam   \
left outer join pg_constraint as con on con.conindid = idx.indexrelid and con.confrelid = 0) a   \
where   \
is_unique = false    \
AND table_schema = ?   \
AND table_name = ?
metadata.query.index-column=select *   \
from(   \
select   \
concat_ws('.',   \
(select nspname from pg_namespace where oid = i.relnamespace),   \
t.relname,   \
i.relname) as current_object_id,   \
(   \
select nspname   \
from pg_namespace   \
where oid = i.relnamespace   \
)                                 as table_schema,   \
t.relname                        as table_name,   \
i.relname                         as index_name,   \
ser.num_column                        as order_column,   \
pg_get_indexdef(idx.indexrelid, ser.num_column, true) as name,   \
case   \
when ser.indoption[ser.k-1] & 1 = 1 then 'DESC'   \
else 'ASC'   \
end                                 as order_by ,   \
case   \
when (ser.indoption[ser.k-1] & 2 = 2) then 'NULLS FIRST'   \
else 'NULLS LAST'   \
end                                 as nulls,   \
case when COALESCE(con.contype,'1') in('p','u') then true   \
else false   \
end                                 as is_unique    \
from   \
pg_index           as idx   \
inner join (   \
select ii.indexrelid as idx_id, unnest(ii.indkey) as k, ii.*, generate_subscripts(ii.indkey, 1)+1 as num_column   \
from pg_index ii   \
)                 as ser on ser.idx_id = idx.indexrelid   \
inner join pg_class         as i  on i.oid  = idx.indexrelid   \
inner join pg_class         as t  on t.oid  = idx.indrelid   \
inner join pg_am         as am on am.oid = i.relam   \
left outer join pg_constraint as con on con.conindid = idx.indexrelid and con.confrelid = 0   \
) a   \
where   \
is_unique = false                         \
AND table_schema = ?   \
AND table_name = ?   \
AND index_name = ?                         \
order by table_schema, table_name, index_name, order_column