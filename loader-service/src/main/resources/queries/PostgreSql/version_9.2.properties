metadata.query.server=SELECT\
   (substring(version(), '[0-9.]+')) AS version, \
   pg_postmaster_start_time()::VARCHAR AS uuid;
metadata.query.database=SELECT d.datname as name, d.datcollate as collation, \
  COALESCE(current_schema(), 'public') as default_schema \
  FROM pg_database d \
  WHERE d.datistemplate = false and d.datname = current_database(); 
metadata.query.schema=select current_database() AS parent_object_id, n.nspname as current_object_id, n.nspname as name, \
  CASE WHEN n.nspname like 'pg\_%' or n.nspname = 'information_schema' THEN 1 ELSE 0 END AS is_system \
  from pg_namespace n \
  where current_database() = ?
metadata.query.extension=select current_database() as parent_object_id, pn.nspname AS schema_name, pe.extname as current_object_id,\
  \ pe.extname as name, pe.extowner, pe.extnamespace, pe.extrelocatable, pe.extversion \
  from pg_extension pe, pg_namespace pn \
  where pe.extnamespace=pn.oid and current_database() = ?
metadata.query.table=select nc.nspname AS parent_object_id, c.relname AS name, \
  concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN t.typname IS NOT NULL THEN  1 ELSE 0 END AS is_typed_table \
  from ((pg_namespace nc JOIN pg_class c ON ((nc.oid = c.relnamespace))) \
  LEFT JOIN (pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid))) \
  where (NOT pg_is_other_temp_schema(nc.oid)) AND (c.relkind = 'r'::"char") AND current_database() = ? AND nc.nspname = ?
metadata.query.view=select c.relname AS name, concat_ws('.', nc.nspname, c.relname) as current_object_id, \
  CASE WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 1 ELSE 0 END as is_updatable, \
  pg_get_viewdef(c.oid) AS text \
  from pg_namespace nc, pg_class c \
  where (c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
  AND current_database() = ? AND nc.nspname = ?
metadata.query.materialized-view=select schemaname as parent_object_id,matviewname as name, \
  schemaname || '.' || matviewname AS current_object_id, ispopulated as is_updatable, hasindexes as has_indexes, \
  definition as text \
  from pg_matviews where current_database() = ? and schemaname = ?
metadata.query.procedure=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.aggregate-function=select \
        sch.nspname as parent_object_id, \
        concat_ws('.', prc.pronamespace, prc.oid) as current_object_id, \
        sch.nspname as schema_name, \
        prc.proname as name, \
        prc.proisagg as is_aggregate, \
        case when typ.typname = 'trigger' then true else false end as is_trigger_function, \
        prorettype::regtype::text as return_type, \
        prc.prosrc as text \
    from \
        pg_proc as prc \
        join pg_namespace as sch on sch.oid = prc.pronamespace \
        join pg_type as typ on typ.oid = prc.prorettype \
    where \
        typ.typname <> 'trigger' \
        and not (prorettype::regtype::text = 'void' OR prorettype::regtype::text = 'refcursor' OR prorettype::regtype::text = 'record') \
        and prc.proisagg = true \
        and current_database() = ? \
        and sch.nspname = ?
metadata.query.sequence=select \
        c.relname AS current_object_id, \
        false as is_udt, \
        c.relname AS name, \
        'bigint'::character varying AS type_name,  \
        p.start_value AS start_value, \
        p.minimum_value AS minimum_value, \
        p.maximum_value AS character_maximum_length, \
        p.increment AS increment, \
        64::information_schema.cardinal_number AS numeric_precision, \
        0::information_schema.cardinal_number AS numeric_scale, \
        CASE WHEN (CASE WHEN p.cycle_option THEN 'YES'::text ELSE 'NO'::text END) = 'YES' THEN true ELSE false END as cycle_option \
        ,false as cache_flag \
        ,null as cache_size \
        ,null as last_value  \
    from    pg_namespace nc, \
        pg_class c, \
        LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option) \
    where \
    (c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) \
        and current_database() = ? \
        and nc.nspname = ?
metadata.query.udt=SELECT \
        m.parent_object_id, \
        m.current_object_id, \
        m.name, \
        m.type_name, \
        m.udt_name, \
        m.udt_schema, \
        coalesce(m.character_maximum_length, m.character_maximum_length_calc) as character_maximum_length, \
        case when trim(m.parent_object_id) is null then false else true end as is_udt, \
        m.domain_schema, \
        m.database, \
        m.numeric_precision, \
        m.numeric_scale, \
        m.allow_nulls, \
        m.is_domain, \
        m.is_type_enum \
    FROM ( \
            SELECT \
                ns.nspname as parent_object_id, \
                current_database() as database, \
                concat_ws('.', ns.nspname, t.typname ) as current_object_id, \
                t.typname as name, \
                CASE \
                WHEN c.data_type = 'USER-DEFINED' \
                THEN replace(replace(format_Type(t.typbasetype,null),c.udt_schema||'.',''),'[]','') \
                ELSE c.data_type \
                END  as type_name, \
                c.udt_name, \
                c.udt_schema, \
                COALESCE(c.domain_schema, '') as domain_schema, \
                c.character_maximum_length, \
                coalesce(c.numeric_precision, c.datetime_precision) as numeric_precision, \
                c.numeric_scale, \
                case when t.typnotnull = 't' then false else true end as allow_nulls, \
                CASE WHEN c.udt_name in ('_char', '_varchar', '_bpchar') THEN \
                CASE WHEN t.typtypmod < 0 THEN null \
                ELSE (t.typtypmod - 4) & 65535 \
                END \
                ELSE null \
                END AS character_maximum_length_calc, \
                CASE WHEN (UPPER(t.typinput::varchar) = 'DOMAIN_IN') THEN true ELSE false END as is_domain, \
                CASE WHEN (upper(t.typinput::varchar) = 'ENUM_IN') THEN true ELSE false END as is_type_enum \
            FROM pg_catalog.pg_type t \
                LEFT JOIN pg_catalog.pg_namespace ns ON t.typnamespace = ns.oid \
                LEFT JOIN information_schema.domains c ON c.domain_name = t.typname and c.domain_schema = ns.nspname \
            WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) \
            AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid) \
            and current_database() = ? \
            AND ns.nspname = ? \
    ) m